<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>The Voronoi finite volume method · VoronoiFVM.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>VoronoiFVM.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><a class="toctext" href="../changes/">Changes</a></li><li class="current"><a class="toctext" href>The Voronoi finite volume method</a><ul class="internal"><li><a class="toctext" href="#Construction-of-control-volumes-1">Construction of control volumes</a></li><li><a class="toctext" href="#The-discretization-approach-1">The discretization approach</a></li><li><a class="toctext" href="#Why-this-method-?-1">Why this method ?</a></li><li><a class="toctext" href="#Why-not-this-method-?-1">Why not this method ?</a></li><li><a class="toctext" href="#History-and-literature-1">History and literature</a></li><li><a class="toctext" href="#Software-API-and-implementation-1">Software API and implementation</a></li></ul></li><li><span class="toctext">API Documentation</span><ul><li><a class="toctext" href="../grid/">Grid</a></li><li><a class="toctext" href="../physics/">Physics</a></li><li><a class="toctext" href="../system/">System</a></li><li><a class="toctext" href="../allindex/">Index</a></li></ul></li><li><span class="toctext">Examples</span><ul><li><a class="toctext" href="../examples/Example101_Laplace1D/">101: 1D Laplace equation</a></li><li><a class="toctext" href="../examples/Example102_StationaryConvectionDiffusion1D/">102: 1D Stationary convection-diffusion equation</a></li><li><a class="toctext" href="../examples/Example105_NonlinearPoisson1D/">105: 1D Nonlinear Poisson equation</a></li><li><a class="toctext" href="../examples/Example106_NonlinearDiffusion1D/">106: 1D Nonlinear Diffusion equation</a></li><li><a class="toctext" href="../examples/Example107_NonlinearStorage1D/">107: 1D Nonlinear Storage</a></li><li><a class="toctext" href="../examples/Example110_NonlinearPoisson1D_TwoSpecies/">110: 1D Nonlinear Poisson equation with two species</a></li><li><a class="toctext" href="../examples/Example115_NonlinearPoisson1D_BoundarySpecies/">-</a></li><li><a class="toctext" href="../examples/Example120_ThreeRegions1D/">120: Differing species sets in regions, 1D</a></li><li><a class="toctext" href="../examples/Example125_TestFunctions1D/">125: Terminal flux calculation via test functions</a></li><li><a class="toctext" href="../examples/Example150_Impedance1D/">150: Impedance calculation</a></li><li><a class="toctext" href="../examples/Example160_UnipolarDriftDiffusion1D/">160: Unipolar degenerate drift-diffusion</a></li><li><a class="toctext" href="../examples/Example203_CoordinateSystems/">203: Various coordinate systems</a></li><li><a class="toctext" href="../examples/Example205_NonlinearPoisson2D/">205: 2D Nonlinear Poisson equation</a></li><li><a class="toctext" href="../examples/Example210_NonlinearPoisson2D_Reaction/">210: 2D Nonlinear Poisson with reaction</a></li><li><a class="toctext" href="../examples/Example215_NonlinearPoisson2D_BoundaryReaction/">215: 2D Nonlinear Poisson with boundary reaction</a></li><li><a class="toctext" href="../examples/Example220_NonlinearPoisson2D_BoundarySpecies/">220: 2D Nonlinear Poisson with boundary reaction and boundary species</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>The Voronoi finite volume method</a></li></ul><a class="edit-page" href="https://github.com/j-fu/VoronoiFVM.jl"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>The Voronoi finite volume method</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="The-Voronoi-finite-volume-method-1" href="#The-Voronoi-finite-volume-method-1">The Voronoi finite volume method</a></h1><h2><a class="nav-anchor" id="Construction-of-control-volumes-1" href="#Construction-of-control-volumes-1">Construction of control volumes</a></h2><ul><li><p>Start with a triangulation of a polygonal domain (intervals in 1D,triangles in 2D, tetrahedra in 3D). Such a triangulation can be generated by e.g. by the mesh generators triangle and TetGen, and - for simple geometries - from tensor products of lower dimensional grids. </p></li><li><p>Join triangle circumcenters by lines <span>$\rightarrow$</span> create Voronoi cells which can serve as control volumes, akin to representative elementary volumes (REV) used to derive conservation laws.</p></li></ul><center>
<img src="../trivoro.png" width="50%">
</center><ul><li>Black + green: triangle nodes</li><li>Gray: triangle edges</li><li>Blue: triangle circumcenters</li><li>Red: Boundaries of Voronoi cells</li></ul><p>This construction requires (in 2D) that sums of angles opposite to triangle edges are less than <span>$\pi$</span> and that angles opposite to boudary edges are less than <span>$\frac\pi2$</span>. This property is called the &quot;boundary conforming Delaunay property&quot;. It has different equivalent definitions and analogues in 3D.</p><p>As a consequence, there is a 1:1 incidence between triangulation nodes and Voronoi cells. Moreover, the angle between the interface between two Voronoi cells and the edge between their corresponding nodes is <span>$\frac\pi2$</span>.</p><p>The idea is now to use these Voronoi cells as REVs aka control volumes aka finite volume cells.</p><h2><a class="nav-anchor" id="The-discretization-approach-1" href="#The-discretization-approach-1">The discretization approach</a></h2><center>
<img src="../vor.png" width="50%">
</center><p>Given a continuity equation <span>$\nabla\cdot \vec j=0$</span> in a domain <span>$\Omega$</span>, integrate this over a contol volume <span>$\omega_k$</span> with associated node <span>$\vec x_k$</span> and apply Gauss theorem:</p><div>\[\begin{aligned}
0&amp;=\int_{\omega_k} \nabla\cdot  \vec j \ d\omega 
=\int_{\partial\omega_k} \vec j\cdot \vec n ds\\
&amp;=\sum_{l\in N_k} \int_{\omega_k\cap \omega_l} \vec j\cdot \vec n ds + \int_{\partial\omega_k\cap \partial\Omega} \vec j\cdot \vec n ds\\
&amp;\approx \sum_{l\in N_k} \frac{\sigma_{kl}}{h_{kl}}g(u_k, u_l)+ \gamma_k b(u_k)
\end{aligned}\]</div><p>Here, <span>$N_k$</span> is the set of neighbor control volumes, <span>$\sigma_{kl}=|\omega_k\cap \omega_l|$</span>, <span>$h_{kl}=|\vec x_k -\vec x_l|$</span>, <span>$\gamma_k=|\partial\omega_k\cap \partial\Omega|$</span>,  where  <span>$|\cdot|$</span> denotes the measure (length resp. area) of a geometrical entity. In the approximation step, we replaced the normal flux integral over the interface between two control volumes by the measure of this interface multiplied by a function depending on the unknowns associated to the respective nodes divided by the distance between these nodes. The second integral has  benn replaced by a boundary condition on the flux <span>$\vec j\cdot \vec n + b(u)=0$</span>. We note that by the very construction, the discretization nodes associated to control volumes adjacent to the domain boundary are located at the domain boundary.</p><p>The flux function <span>$g$</span> can be derived from usual finite difference formulas.</p><p>For instance, for the diffusion flux <span>$\vec j=-D\vec\nabla u$</span>, we use <span>$g(u_k, u_l)=D(u_k -u_l)$</span>.</p><p>For a convective diffusion flux <span>$\vec j = -D\vec \nabla u + u \vec v$</span>, one can chose the upwind flux</p><div>\[\begin{aligned}
g(u_k, u_l)=D(u_k -u_l) + 
v_{kl}\begin{cases}
u_k,&amp; v_{kl}&gt;0\\
u_l,&amp; v_{kl}\leq 0,
\end{cases}
\end{aligned}\]</div><p>where <span>$v_{kl}=\frac{h_{kl}}{\sigma_{kl}}\int_{\omega_k\cap \omega_l} \vec v \cdot \vec n_{kl} \ ds$</span> Fluxes also can depend nonlinearily on <span>$u$</span>.</p><p>This approach easily generalizes to time dependent nonlinear transport-reaction problems with storage terms <span>$s(u)$</span>, reaction terms <span>$r(u)$</span> and source terms <span>$f$</span>:</p><div>\[\partial_t s(u) + \nabla \cdot \vec j + r(u) -f =0\]</div><p>Semidiscretization in time (for implicit Euler) leads to </p><div>\[\frac{s(u)-s(u^\flat)}{\tau} + \nabla \cdot \vec j + r(u) -f =0\]</div><p>where <span>$\tau$</span> is the time step size and <span>$u^\flat$</span> is the solution from the old timestep. The approximation  approach then for each control volume gives</p><div>\[|\omega_k|\frac{s(u_k)-s(u_k^\flat)}{\tau} + \sum_{l\in N_k} \frac{\sigma_{kl}}{h_{kl}}g(u_k, u_l)+ \gamma_k b(u_k) + |\omega_k| (r(u_k)- f(\vec x_k))=0\]</div><p>If <span>$n$</span> is the number of discretization nodes, we get a system of <span>$n$</span> equations with <span>$n$</span> unknowns which under proper conditions on <span>$r,g,s,b$</span> has a unique solution.</p><p>This approach generalizes to systems of <span>$m$</span> partial differential equations, which formally can be written in the same way, but assuming that <span>$u$</span> is an <span>$m$</span>-vector function of <span>$\vec x,t$</span>, and <span>$r,g,b,s$</span> are <span>$m$</span>-vector funtions of their arguments.</p><h2><a class="nav-anchor" id="Why-this-method-?-1" href="#Why-this-method-?-1">Why this method ?</a></h2><p>Independent of space dimension, the method (with properly chosen flux functions) is able to preserve a number of physical quantities if they are present on the continuous level:</p><ul><li>local and global mass conservation</li><li>positivity of solutions</li><li>maximum principle: in the absence of source and reaction terms, local extrema of the stationary solution are located at the domain boudaries, never in the interior. For transient problems, local extrema in the interior can only come from the initial value. </li><li>Consistency to thermodynamics: entropy production etc.</li></ul><p>Many of these properties are hard to prove for finite element methods, in particular for the convection-diffusion case.</p><h2><a class="nav-anchor" id="Why-not-this-method-?-1" href="#Why-not-this-method-?-1">Why not this method ?</a></h2><p>There are a number of cases where this method needs replaces by something else or at least to be applied with great care:</p><ul><li>Anisotropic diffusion only works with proper mesh alignment </li><li>Strongly varying capacity (in the function s) at domain interfaces lead to inexact breaktrough curves</li><li>Sharp moving convection fronts are smeared out too strongly</li></ul><h2><a class="nav-anchor" id="History-and-literature-1" href="#History-and-literature-1">History and literature</a></h2><p>The following list  is work in progress and incomplete, but it references some sources behind the ideas in this package.</p><ul><li>Macneal, R. H. (1953). An asymmetrical finite difference network. Quarterly of Applied Mathematics, 11(3), 295-310.  (<a href="https://www.jstor.org/stable/pdf/43634052.pdf">pdf</a> via JSTOR). Perhaps this is the earliest mentioning of the method. Note that it  was used on an electrical analog computer. </li><li>Gärtner, K., &amp; Kamenski, L. (2019). Why do we need Voronoi cells and Delaunay meshes? <a href="https://arxiv.org/pdf/1905.01738">arXiv preprint arXiv:1905.01738</a>. A recent overview on the merits of the method. One of the authors belongs to the pioneers of its application in 3D.</li><li>Fuhrmann, J., &amp; Langmach, H. (2001). Stability and existence of solutions of time-implicit finite volume schemes for viscous nonlinear conservation laws. Applied Numerical Mathematics, 37(1-2), 201-230. A discussion of the method applied to rather general nonlinear scalar problems.</li><li>Si, H., Gärtner, K., &amp; Fuhrmann, J. (2010). Boundary conforming Delaunay mesh generation. Computational Mathematics and Mathematical Physics, 50(1), 38-53. Definition of the boundary conforming Delaunay property. </li><li>Eymard, R., Fuhrmann, J., &amp; Gärtner, K. (2006). A finite volume scheme for nonlinear parabolic equations derived from one-dimensional local Dirichlet problems. Numerische Mathematik, 102(3), 463-495. General concept of the derivation of upwind fluxes for nonlinear problems.</li><li>Farrell, P., Rotundo, N., Doan, D. H., Kantner, M., Fuhrmann, J., &amp; Koprucki, T. (2017). Drift-diffusion models. In Handbook of Optoelectronic Device Modeling and Simulation (pp. 733-772). CRC Press. Overview and introduction to the method applied to semiconductor device simulation. This problem class profits most from the desirable properties of the method.</li></ul><h2><a class="nav-anchor" id="Software-API-and-implementation-1" href="#Software-API-and-implementation-1">Software API and implementation</a></h2><p>The entities describing the discrete system can be subdivided into two categories:</p><ul><li>geometrical data: <span>$|\omega_k|, \gamma_k, \sigma_{kl}, h_{kl}$</span> together with the connectivity information of the triangles</li><li>physical data: the number <span>$m$</span> and the functions <span>$s,g,r,b,f$</span> describing the particular problem.</li></ul><p>This structure allows to describe the problem to be solved by data derived from the discretization grid and by the functions describing the physics, giving rise to a software API.</p><p>The solution of the nonlinear systems of equations can be performed by Newton&#39;s method combined with various direct and iterative linear solvers.</p><p>The generic programming capabilities of Julia allow for an implementation of the method which results in an API which consists in  the implementation of functions <span>$s,g,r,b,f$</span> without the need to write code for their derivatives.</p><footer><hr/><a class="previous" href="../changes/"><span class="direction">Previous</span><span class="title">Changes</span></a><a class="next" href="../grid/"><span class="direction">Next</span><span class="title">Grid</span></a></footer></article></body></html>
